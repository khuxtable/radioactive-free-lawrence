// When eating or drinking something
proc consume obj disappears count minPower maxPower message emptyDescription {
    var power = getrandom(minPower, maxPower);
    player.power += power;
    // I don't currently hae a way to implement the count, so assume 1 and disappears = true.
    apport(obj, ylem);
    say(message);
    break repeat;
}
proc useweapon affects rchance damage drain {
    quip("nfw");
}
proc say.message msg {
    quip(msg);
}
proc say.and.move mykey where msg {
    if (key(mykey)) {
        say(msg);
        move(where);
    }
}
proc beast.check bst where no.can.do {
    //quip(no.can.do);
    move(where);
}

action "read" "meter" {
    quip("You have $ life force.", player.power);
}
action "inventory" {
    var count;
    for (var optr : inhand) {
        say(optr);
        count++;    // Increment count of listed objects
    }
    if (count == 0) {                             // If nothing listed, ...
        say("You are not carrying anything.");   // ... say_ empty-handed
    }
    break repeat;              // Command fully handled, so terminate the REPEAT loop
}
action "take" "inventory" {
    "inventory"();     // Execute code associated with the INVENTORY command
}
action "look" {
    if (status == 1) {
        describe(here, 1);        // The procedure does not QUIT...
        var youSee = true;
        for (var optr : here) {
            if (youSee) {
                say("");
                youSee = false;
            }
            describe(optr);
        }
        break repeat;          // ... so QUIT explicitly
    }
    if (status == 2 && isnear(arg2)) {
        describe(arg2);        // Otherwise give long object description
        break repeat;
    }
}
action "describe" {
    describe(arg2);
    break repeat;
}
action "take" {
    if (ishere(arg2)) {
        if (isflag(arg2, cant.take)) {
            quip("You cannot take the #.", arg2);
        }
        get(arg2);
        quip("You take the #.", arg2);
    } else {
        quip("I see no # here.", arg2);
    }
}
action "steal" {

}
action "drop" {
    if (have(arg2)) {      // True only if the player has the thing
        if (isflag(*arg2, cant.drop)) {
            quip("You cannot drop the #.", arg2);
        }
        say("You drop the #.", arg2);
        drop(arg2);          // Move the thing from player's inventory to here
        break repeat;
    } else {
       quip("You have no #", arg2);
    }
}
action "vocabulary" {
    respond(verbs, vocab_verbs);
    if (key(nouns)) {
        show_nouns();
    }
    respond(travel, vocab_travel);
    respond(screen, vocab_screen);
    if (status == 1 || key(all)) {
        say(vocab_general);
        set(context, q_vocab_0);
        quip("more?");
    }
}
action "swing" "axe" {

}
action "throw" "axe" {

}
action "eat" "banana" {

}
action "eat" "sandwich" {

}
action "open" "book" {
    if (have(book)) {
        quip("The pages are fused together.");
    }
}
action "read" "book" {
    if (have(book)) {
        quip("The book is closed. The cover reads 'How to Survive a Nuclear War.'");
    }
}
action "throw" "box" {
//    "action": "AlterPower",
//    "flag": 0,
//    "chance": 100,
//    "minPower": 2000,
//    "maxPower": 2000,
//    "success": "Congratulations! You have found the treasure.\nYou are hereby awarded with 200% life force.",
//    "failure": "The interior is filled with meters and other strange appurtenances,\nbut nothing seems to happen."
}
action "open" "box" {

}
action "belt" "chain" {
//    "action": "UseWeapon",
//    "affects": 3,
//    "chance": 50,
//    "damage": 75,
//    "drain": 0
}
