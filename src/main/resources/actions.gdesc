// When eating or drinking something
proc consume(obj, disappears, count, minPower, maxPower, message, emptyDescription) {
    var power = getrandom(minPower, maxPower);
    playerPower += power;
    // I don't currently hae a way to implement the count, so assume 1 and disappears = true.
    apport(obj, ylem);
    say(message);
    break repeat;
}
proc useweapon(affects, rchance, damage, drain) {
    quip("nfw");
}
proc beastCheck(beast, where, noCanDo) {
    //quip(noCanDo);
    move(where);
}
proc countAndMove(countvar, max, notDone, destination, destinationMessage) {
    if (*countvar <= 0) {
        *countvar = max;
    }
    if (--*countvar > 0) {
        quip(notDone);
    } else {
        say(destinationMessage);
        move(destination);
    }
}

action "die" {
    playerPower = -1;
}
action "read" "meter" {
    quip("You have $ life force.", playerPower);
}
action "inventory" {
    var count;
    for (var optr : inhand) {
        say(optr);
        count++;    // Increment count of listed objects
    }
    if (count == 0) {                             // If nothing listed, ...
        say("You are not carrying anything.");   // ... say_ empty-handed
    }
    break repeat;              // Command fully handled, so terminate the REPEAT loop
}
action "take" "inventory" {
    "inventory"();     // Execute code associated with the INVENTORY command
}
action "look" {
    if (status == 1) {
        describe(here, 1);        // The procedure does not QUIT...
        var youSee = true;
        for (var optr : here) {
            if (youSee) {
                say("");
                youSee = false;
            }
            describe(optr);
        }
        break repeat;          // ... so QUIT explicitly
    }
    if (status == 2 && isnear(arg2)) {
        describe(arg2);        // Otherwise give long object description
        break repeat;
    }
}
action "describe" {
    describe(arg2);
    break repeat;
}
action "take" {
    if (ishere(arg2)) {
        if (isflag(*arg2, cantTake)) {
            quip("You cannot take the #.", arg2);
        }
        get(arg2);
        quip("You take the #.", arg2);
    } else {
        quip("I see no # here.", arg2);
    }
}
action "steal" {

}
action "drop" {
    if (have(arg2)) {      // True only if the player has the thing
        if (isflag(*arg2, cantDrop)) {
            quip("You cannot drop the #.", arg2);
        }
        say("You drop the #.", arg2);
        drop(arg2);          // Move the thing from player's inventory to here
        break repeat;
    } else {
       quip("You have no #", arg2);
    }
}
action "vocabulary" {
    vocab();
}
action "swing" "axe" {

}
action "throw" "axe" {

}
action "eat" "banana" {

}
action "eat" "sandwich" {

}
action "open" "book" {
    if (have(book)) {
        quip("The pages are fused together.");
    }
}
action "read" "book" {
    if (have(book)) {
        quip("The book is closed. The cover reads 'How to Survive a Nuclear War.'");
    }
}
action "throw" "box" {
//    "action": "AlterPower",
//    "flag": 0,
//    "chance": 100,
//    "minPower": 2000,
//    "maxPower": 2000,
//    "success": "Congratulations! You have found the treasure.\nYou are hereby awarded with 200% life force.",
//    "failure": "The interior is filled with meters and other strange appurtenances,\nbut nothing seems to happen."
}
action "open" "box" {

}
action "belt" "chain" {
//    "action": "UseWeapon",
//    "affects": 3,
//    "chance": 50,
//    "damage": 75,
//    "drain": 0
}
